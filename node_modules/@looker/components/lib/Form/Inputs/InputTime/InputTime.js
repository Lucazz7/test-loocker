"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputTime = exports.convert12To24HrString = void 0;

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _noop = _interopRequireDefault(require("lodash/noop"));

var _add = _interopRequireDefault(require("lodash/add"));

var _subtract = _interopRequireDefault(require("lodash/subtract"));

var _InputText = require("../InputText");

var _innerInputStyle = require("../innerInputStyle");

var _Icon = require("../../../Icon");

var _simple = require("../../../Layout/utils/simple");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var initialState = {
  charCount: 0,
  format: '12h',
  hour: '',
  isComplete: false,
  minute: '',
  period: '',
  subInputFocus: 'NONE'
};

var isNumericKey = e => e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 96 && e.keyCode <= 105;

var isArrowKey = e => e.key === 'ArrowUp' || e.key === 'ArrowDown';

var isDeleteKey = e => {
  return e.key === 'Backspace' || e.key === 'Delete';
};

var selectNextInput = current => {
  switch (current) {
    case 'HOUR':
      return 'MINUTE';

    case 'MINUTE':
      return 'PERIOD';

    case 'PERIOD':
      return 'NONE';

    default:
      return 'NONE';
  }
};

var isInputComplete = (_ref) => {
  var {
    format,
    hour,
    minute,
    period
  } = _ref;

  if (format === '12h') {
    return !!(hour.length && minute.length && period.length);
  }

  return !!(hour.length && minute.length);
};

var reducer = (state, action) => {
  var {
    payload,
    type
  } = action;
  var inputValues = {
    format: state.format,
    hour: state.hour,
    minute: state.minute,
    period: state.period
  };

  switch (type) {
    case 'SET_FOCUS':
      return _objectSpread(_objectSpread({}, state), {}, {
        subInputFocus: payload
      });

    case 'FOCUS_NEXT_FIELD':
      return _objectSpread(_objectSpread({}, state), {}, {
        subInputFocus: selectNextInput(state.subInputFocus)
      });

    case 'INCREMENT_CHAR_COUNT':
      return _objectSpread(_objectSpread({}, state), {}, {
        charCount: state.charCount + 1
      });

    case 'RESET_CHAR_COUNT':
      return _objectSpread(_objectSpread({}, state), {}, {
        charCount: 0
      });

    case 'SET_HOUR_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        hour: payload,
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          hour: payload
        }))
      });

    case 'SET_MINUTE_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          minute: payload
        })),
        minute: payload
      });

    case 'SET_PERIOD_VALUE':
      return _objectSpread(_objectSpread({}, state), {}, {
        isComplete: isInputComplete(_objectSpread(_objectSpread({}, inputValues), {}, {
          period: payload
        })),
        period: payload
      });

    default:
      return state;
  }
};

var cycleValue = (currentValue, key, max, min) => {
  var transform = key === 'ArrowUp' ? _add.default : _subtract.default;
  var newValue = transform((0, _utils.parseBase10Int)(currentValue), 1);

  if (newValue < min) {
    return (0, _utils.formatTimeString)(max);
  } else if (newValue > max) {
    return (0, _utils.formatTimeString)(min);
  } else {
    return (0, _utils.formatTimeString)(newValue);
  }
};

var parseValue = function parseValue(format) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (value.length) {
    var [hr24, minute] = value.split(':').map(_utils.parseBase10Int);
    var hr12 = hr24 <= 12 ? hr24 : hr24 - 12;
    var period = hr24 >= 12 ? 'PM' : 'AM';
    return [(0, _utils.formatTimeString)(format === '12h' ? hr12 : hr24), (0, _utils.formatTimeString)(minute), period];
  }

  return ['', '', ''];
};

var convert12To24HrString = value => {
  var period = value.includes('P') ? 'PM' : 'AM';
  var numericTime = value.replace(/[APM]/gi, '');
  var [hour = 0, minute = 0] = numericTime.split(':').map(_utils.parseBase10Int);
  var hr24;

  if (period === 'AM' && hour === 12) {
    hr24 = 0;
  } else if (period === 'PM' && hour < 12) {
    hr24 = hour + 12;
  } else {
    hr24 = hour;
  }

  return "".concat((0, _utils.formatTimeString)(hr24), ":").concat((0, _utils.formatTimeString)(minute));
};

exports.convert12To24HrString = convert12To24HrString;
var InputTimeInternal = (0, _react.forwardRef)((_ref2, ref) => {
  var {
    className,
    defaultValue,
    disabled,
    format = '12h',
    id,
    onChange,
    readOnly,
    onBlur,
    onFocus,
    onValidationFail,
    required,
    validationType,
    value
  } = _ref2;
  var [inputState, dispatch] = (0, _react.useReducer)(reducer, _objectSpread(_objectSpread({}, initialState), {}, {
    format
  }));
  var {
    hour,
    minute,
    period,
    isComplete,
    subInputFocus
  } = inputState;
  var inputRefs = {
    HOUR: (0, _react.useRef)(null),
    MINUTE: (0, _react.useRef)(null),
    NONE: (0, _react.useRef)(null),
    PERIOD: (0, _react.useRef)(null)
  };

  var handleValidKeyDown = () => {
    dispatch({
      type: 'INCREMENT_CHAR_COUNT'
    });

    if (inputState.charCount > 0) {
      dispatch({
        type: 'FOCUS_NEXT_FIELD'
      });
    }
  };

  var handleDelete = setStateCB => {
    onChange && onChange(undefined);
    setStateCB();
  };

  var handleHourKeyDown = e => {
    var clearHourField = () => {
      dispatch({
        payload: '',
        type: 'SET_HOUR_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    if (isNumericKey(e)) {
      var _value = (0, _utils.parseBase10Int)(inputState.charCount === 1 ? "".concat(hour).concat(e.key) : e.key);

      if (_value < 24) {
        if (format === '12h' && _value > 12) {
          dispatch({
            payload: (0, _utils.formatTimeString)(_value - 12),
            type: 'SET_HOUR_VALUE'
          });
          dispatch({
            payload: 'PM',
            type: 'SET_PERIOD_VALUE'
          });
        } else {
          dispatch({
            payload: (0, _utils.formatTimeString)(_value),
            type: 'SET_HOUR_VALUE'
          });
        }

        handleValidKeyDown();
      } else {
        clearHourField();
      }
    } else if (isArrowKey(e)) {
      var max = format === '12h' ? 12 : 23;
      var min = format === '12h' ? 1 : 0;
      dispatch({
        payload: cycleValue(hour, e.key, max, min),
        type: 'SET_HOUR_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearHourField);
    }
  };

  var handleMinuteKeyDown = e => {
    var clearMinuteField = () => {
      dispatch({
        payload: '',
        type: 'SET_MINUTE_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    if (isNumericKey(e)) {
      var _value2 = (0, _utils.parseBase10Int)(inputState.charCount === 1 ? "".concat(minute).concat(e.key) : e.key);

      if (_value2 < 60) {
        dispatch({
          payload: (0, _utils.formatTimeString)(_value2),
          type: 'SET_MINUTE_VALUE'
        });
        handleValidKeyDown();
      } else {
        clearMinuteField();
      }
    } else if (isArrowKey(e)) {
      dispatch({
        payload: cycleValue(minute, e.key, 59, 0),
        type: 'SET_MINUTE_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearMinuteField);
    }
  };

  var handlePeriodKeyDown = e => {
    var clearPeriodField = () => {
      dispatch({
        payload: '',
        type: 'SET_PERIOD_VALUE'
      });
      dispatch({
        type: 'RESET_CHAR_COUNT'
      });
    };

    var key = e.key.toUpperCase();

    if (key === 'P' || key === 'A') {
      dispatch({
        payload: "".concat(key, "M"),
        type: 'SET_PERIOD_VALUE'
      });
      handleValidKeyDown();
    } else if (isArrowKey(e)) {
      var nextPeriod = period === 'PM' ? 'AM' : 'PM';
      dispatch({
        payload: nextPeriod,
        type: 'SET_PERIOD_VALUE'
      });
    } else if (isDeleteKey(e)) {
      handleDelete(clearPeriodField);
    }
  };

  var handleHourFocus = () => dispatch({
    payload: 'HOUR',
    type: 'SET_FOCUS'
  });

  var handleMinuteFocus = () => dispatch({
    payload: 'MINUTE',
    type: 'SET_FOCUS'
  });

  var handlePeriodFocus = () => dispatch({
    payload: 'PERIOD',
    type: 'SET_FOCUS'
  });

  var handleBlur = () => {
    dispatch({
      payload: 'NONE',
      type: 'SET_FOCUS'
    });
    dispatch({
      type: 'RESET_CHAR_COUNT'
    });
  };

  (0, _react.useEffect)(() => {
    var ref = inputRefs[subInputFocus || ''];

    if (ref.current) {
      ref.current.focus();
    }
  }, [subInputFocus]);
  (0, _react.useEffect)(() => {
    var valueProp = value || defaultValue;

    if ((0, _utils.isValidTime)(valueProp)) {
      var [newHour, newMinute, newPeriod] = parseValue(format, valueProp);
      hour !== newHour && dispatch({
        payload: newHour,
        type: 'SET_HOUR_VALUE'
      });
      minute !== newMinute && dispatch({
        payload: newMinute,
        type: 'SET_MINUTE_VALUE'
      });
      period !== newPeriod && dispatch({
        payload: newPeriod,
        type: 'SET_PERIOD_VALUE'
      });
    } else {
      onValidationFail && onValidationFail(valueProp);
      console.error("Invalid time (\"".concat(valueProp, "\") passed to <InputTime />. Value should be formatted as a 24-hour string (e.g. value=\"02:00\" or value=\"23:15\")."));
    }
  }, [value]);
  (0, _react.useEffect)(() => {
    if (isComplete) {
      var newValue = format === '12h' ? convert12To24HrString("".concat(hour, ":").concat(minute, " ").concat(period)) : "".concat(hour, ":").concat(minute);

      if (newValue !== value) {
        onChange && onChange("".concat(newValue));
      }
    }
  }, [isComplete, hour, minute, period]);
  return _react.default.createElement("div", {
    className: "".concat(className, " ").concat(disabled && 'disabled'),
    ref: ref,
    onFocus: onFocus,
    onBlur: onBlur,
    "aria-invalid": validationType === 'error' ? 'true' : undefined
  }, _react.default.createElement(StyledInput, {
    id: id,
    value: hour,
    onKeyDown: readOnly ? _noop.default : handleHourKeyDown,
    onFocus: handleHourFocus,
    onBlur: handleBlur,
    onChange: _noop.default,
    ref: inputRefs.HOUR,
    "data-testid": "input-hour",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }), _react.default.createElement("div", null, ":"), _react.default.createElement(StyledInput, {
    value: minute,
    onKeyDown: readOnly ? _noop.default : handleMinuteKeyDown,
    onFocus: handleMinuteFocus,
    onBlur: handleBlur,
    onChange: _noop.default,
    ref: inputRefs.MINUTE,
    "data-testid": "input-minute",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }), format === '12h' ? _react.default.createElement(StyledInput, {
    value: period,
    onKeyDown: readOnly ? _noop.default : handlePeriodKeyDown,
    onFocus: handlePeriodFocus,
    onBlur: handleBlur,
    onChange: _noop.default,
    ref: inputRefs.PERIOD,
    "data-testid": "input-period",
    disabled: disabled,
    readOnly: readOnly,
    required: required
  }) : _react.default.createElement("span", null), validationType && _react.default.createElement(WarningIcon, {
    name: "CircleInfo",
    color: "critical",
    "grid-area": "warning",
    size: 20
  }));
});
var WarningIcon = (0, _styledComponents.default)(_Icon.Icon).withConfig({
  displayName: "InputTime__WarningIcon",
  componentId: "plt6tg-0"
})([""]);

var StyledInput = _styledComponents.default.input.attrs({
  maxLength: 2,
  placeholder: '--',
  type: 'text'
}).withConfig({
  displayName: "InputTime__StyledInput",
  componentId: "plt6tg-1"
})(["", " font-size:", ";height:34px;line-height:", ";padding:0;text-align:center;width:1.25rem;&:focus{background:", ";}"], _innerInputStyle.innerInputStyle, props => props.theme.fontSizes.small, (_ref3) => {
  var {
    theme
  } = _ref3;
  return theme.lineHeights.medium;
}, (_ref4) => {
  var {
    theme
  } = _ref4;
  return theme.colors.keyAccent;
});

var InputTime = (0, _styledComponents.default)(InputTimeInternal).withConfig({
  displayName: "InputTime",
  componentId: "plt6tg-2"
})(["", " ", " align-items:center;display:inline-grid;grid-gap:0.15rem;grid-template-columns:auto auto auto auto 1fr;padding:0 ", ";", "{justify-self:end;}&:focus-within{", "}&:hover{", "}&.disabled{", "}", ""], _simple.simpleLayoutCSS, _InputText.inputCSS, (_ref5) => {
  var {
    theme
  } = _ref5;
  return theme.space.xsmall;
}, WarningIcon, _InputText.inputTextFocus, _InputText.inputTextHover, _InputText.inputTextDisabled, _InputText.inputTextValidation);
exports.InputTime = InputTime;
//# sourceMappingURL=InputTime.js.map