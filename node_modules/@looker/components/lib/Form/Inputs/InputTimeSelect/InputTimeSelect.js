"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InputTimeSelect = void 0;

var _react = _interopRequireWildcard(require("react"));

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _reduce = _interopRequireDefault(require("lodash/reduce"));

var _map = _interopRequireDefault(require("lodash/map"));

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _find = _interopRequireDefault(require("lodash/find"));

var _trim = _interopRequireDefault(require("lodash/trim"));

var _last = _interopRequireDefault(require("lodash/last"));

var _head = _interopRequireDefault(require("lodash/head"));

var _sortedIndex = _interopRequireDefault(require("lodash/sortedIndex"));

var _Combobox = require("../Combobox");

var _utils = require("../../../utils");

var _utils2 = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var cycleHourDisplay = (format, hour) => {
  if (format === '12h') {
    if (hour === 0) {
      return 12;
    } else if (hour > 12) {
      return hour - 12;
    }
  }

  return hour;
};

var formatLabel = (format, hour, minute) => {
  var formattedHour = (0, _utils2.formatTimeString)(cycleHourDisplay(format, hour));
  var formattedMinute = (0, _utils2.formatTimeString)(minute);
  var period = format === '12h' && (hour < 12 ? 'am' : 'pm');
  return (0, _trim.default)("".concat(formattedHour, ":").concat(formattedMinute, " ").concat(period || ''));
};

var generateMinuteIntervals = interval => {
  var minutes = new Array(60 / interval);
  return (0, _map.default)(minutes, (_, index) => (0, _utils2.formatTimeString)(index * interval));
};

var generateTimes = (format, interval) => {
  var hours = new Array(24);
  var minutes = generateMinuteIntervals(interval);
  return (0, _reduce.default)(hours, (result, _, hour) => {
    var formatLabel = format === '12h' && (hour < 12 ? 'am' : 'pm');
    var formattedHour = (0, _utils2.formatTimeString)(cycleHourDisplay(format, hour));
    var hourWithMinutes = (0, _map.default)(minutes, minute => {
      var label = (0, _trim.default)("".concat(formattedHour, ":").concat(minute, " ").concat(formatLabel || ''));
      var value = "".concat((0, _utils2.formatTimeString)(hour), ":").concat(minute);
      return {
        label,
        value
      };
    });
    return [...result, ...hourWithMinutes];
  }, []);
};

var matchClosestMinute = (interval, timeCode) => {
  var minuteOptions = (0, _map.default)(generateMinuteIntervals(interval), _utils2.parseBase10Int);
  var now = new Date(Date.now());
  var currentMinute = timeCode ? (0, _utils2.parseBase10Int)(timeCode.split(':')[1]) : now.getMinutes();
  var currentHour = timeCode ? (0, _utils2.parseBase10Int)(timeCode.split(':')[0]) : now.getHours();
  var index = (0, _sortedIndex.default)(minuteOptions, currentMinute);
  var optionBefore = minuteOptions[index - 1] || (0, _head.default)(minuteOptions);
  var optionAfter = minuteOptions[index] || (0, _last.default)(minuteOptions);
  var roundedMinute = currentMinute - optionBefore < optionAfter - currentMinute ? optionBefore : optionAfter;
  var formattedHour = (0, _utils2.formatTimeString)(currentHour);
  var formattedMinute = (0, _utils2.formatTimeString)(roundedMinute);
  return "".concat(formattedHour, ":").concat(formattedMinute);
};

var createOptionFromStringValue = (format, value) => {
  var [hour, minute] = (0, _map.default)(value.split(':'), _utils2.parseBase10Int);
  return {
    label: formatLabel(format, hour, minute),
    value
  };
};

var createOptionFromLabel = (format, label) => {
  var period = label.toLowerCase().includes('p') ? 'pm' : 'am';
  var numericTime = label.replace(/[apm]/gi, '');
  var [hour = 0, minute = 0] = numericTime.split(':').map(_utils2.parseBase10Int);
  var hr24 = hour + (period === 'pm' ? 12 : 0);
  var value = "".concat((0, _utils2.formatTimeString)(hr24), ":").concat((0, _utils2.formatTimeString)(minute));

  if ((0, _utils2.isValidTime)(value)) {
    return {
      label: formatLabel(format, hr24, minute),
      value
    };
  }

  return undefined;
};

var matchStringValueToOption = (options, format, value) => {
  if (value && (0, _utils2.isValidTime)(value)) {
    var option = (0, _find.default)(options, {
      value: value
    });
    return option || createOptionFromStringValue(format, value);
  }

  return undefined;
};

var matchStringLabelToOption = (options, label) => {
  if (label) {
    return (0, _find.default)(options, o => {
      return o.label ? o.label.includes(label) : false;
    });
  }

  return undefined;
};

var setScrollIntoView = (options, interval, selectedOption) => {
  if (selectedOption) {
    return (0, _map.default)(options, option => matchClosestMinute(interval, selectedOption.value) === option.value ? _objectSpread(_objectSpread({}, option), {}, {
      scrollIntoView: true
    }) : option);
  }

  var now = matchClosestMinute(interval);
  return (0, _map.default)(options, option => option.value === now ? _objectSpread(_objectSpread({}, option), {}, {
    scrollIntoView: true
  }) : option);
};

var InputTimeSelectLayout = (0, _react.forwardRef)((_ref, ref) => {
  var {
    className,
    interval = 15,
    format = '12h',
    onChange,
    value = '',
    defaultValue,
    validationType
  } = _ref;
  (0, _utils.useReadOnlyWarn)('InputTimeSelect', value, onChange);
  var valueProp = value || defaultValue;

  if (!(0, _utils2.isValidTime)(valueProp)) {
    console.error("Invalid time (\"".concat(valueProp, "\") passed to <InputTimeSelect />. Value should be formatted as a 24-hour string (e.g. value=\"02:00\" or value=\"23:15\")."));
  }

  var timeOptions = generateTimes(format, interval);
  var [selectedOption, setSelectedOption] = (0, _react.useState)();
  var [inputTextValue, setInputTextValue] = (0, _react.useState)('');
  (0, _react.useEffect)(() => {
    setSelectedOption(matchStringValueToOption(timeOptions, format, value || defaultValue));
  }, [value]);

  var handleChange = newSelectedOption => {
    setSelectedOption(newSelectedOption);
    var newValue = newSelectedOption ? newSelectedOption.value : undefined;

    if ((0, _isFunction.default)(onChange) && (0, _utils2.isValidTime)(newValue)) {
      onChange(newValue);
    }
  };

  var handleTextInputChange = e => {
    setInputTextValue(e.target.value);
  };

  var handleTextInputBlur = () => {
    setInputTextValue('');
  };

  var handleKeyDown = e => {
    if (e.key === 'Enter' || e.key === 'Tab') {
      if (inputTextValue.length) {
        var option = createOptionFromLabel(format, inputTextValue);
        handleChange(option);
      }
    }
  };

  var optionToFocus = matchStringLabelToOption(timeOptions, inputTextValue) || selectedOption;
  var timeOptionsFocused = setScrollIntoView(timeOptions, interval, optionToFocus);
  return _react.default.createElement(_Combobox.Combobox, {
    className: className,
    ref: ref,
    onChange: handleChange,
    value: selectedOption
  }, _react.default.createElement(_Combobox.ComboboxInput, {
    placeholder: "Select time",
    onChange: handleTextInputChange,
    onBlur: handleTextInputBlur,
    onKeyDown: handleKeyDown,
    autoComplete: false,
    validationType: validationType
  }), _react.default.createElement(_Combobox.ComboboxList, {
    persistSelection: true
  }, timeOptionsFocused.map((option, index) => _react.default.createElement(_Combobox.ComboboxOption, _extends({}, option, {
    key: index
  })))));
});
InputTimeSelectLayout.displayName = 'InputTimeSelectLayout';
var InputTimeSelect = (0, _styledComponents.default)(InputTimeSelectLayout).withConfig({
  displayName: "InputTimeSelect",
  componentId: "jpi7di-0"
})(["width:100%;"]);
exports.InputTimeSelect = InputTimeSelect;
//# sourceMappingURL=InputTimeSelect.js.map