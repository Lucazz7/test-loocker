"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInputEvents = useInputEvents;

var _react = require("react");

var _utils = require("../../../../utils");

var _state = require("./state");

var _useBlur = require("./useBlur");

var _useKeyDown = require("./useKeyDown");

function checkForButton(element, containingAncestor) {
  if (element === containingAncestor) return false;
  if (!element.parentElement) return false;

  if (element.tagName === 'BUTTON') {
    return true;
  }

  return checkForButton(element.parentElement, containingAncestor);
}

function useInputEvents(_ref, context) {
  var {
    selectOnClick = false,
    readOnly = false,
    onClick,
    onMouseDown,
    onKeyDown,
    onBlur,
    onFocus
  } = _ref;
  var {
    data: {
      lastActionType
    },
    inputElement,
    openOnFocus,
    persistSelectionPropRef,
    state,
    transition
  } = (0, _react.useContext)(context);
  var selectOnClickRef = (0, _react.useRef)(false);
  var handleKeyDown = (0, _useKeyDown.useKeyDown)();
  var handleBlur = (0, _useBlur.useBlur)(context);

  function handleFocus(e) {
    if (readOnly) {
      e.currentTarget.selectionEnd = e.currentTarget.selectionStart;
    } else if (selectOnClick) {
      selectOnClickRef.current = true;
    }

    if (openOnFocus && lastActionType !== _state.ComboboxActionType.SELECT_WITH_CLICK && lastActionType !== _state.ComboboxActionType.NAVIGATE) {
      transition && transition(_state.ComboboxActionType.FOCUS, {
        persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
      });
    }
  }

  var selectText = (0, _react.useCallback)(() => {
    if (selectOnClickRef.current) {
      selectOnClickRef.current = false;
      inputElement && inputElement.select();
    }
  }, [inputElement]);
  var handleMouseDownClick = (0, _react.useCallback)(e => {
    if (checkForButton(e.target, e.currentTarget)) {
      return;
    }

    if (state === _state.ComboboxState.IDLE) {
      transition && transition(_state.ComboboxActionType.FOCUS, {
        persistSelection: persistSelectionPropRef && persistSelectionPropRef.current
      });
    } else {
      transition && transition(_state.ComboboxActionType.ESCAPE);
    }

    if (e.type === 'click') {
      selectText();
    }
  }, [persistSelectionPropRef, state, selectText, transition]);
  var handleMouseUp = (0, _react.useCallback)(e => {
    if (e.target === inputElement) {
      selectText();
    }
  }, [inputElement, selectText]);
  var {
    onMouseDown: handleMouseDown,
    onClick: handleClick
  } = (0, _utils.useMouseDownClick)(handleMouseDownClick, handleMouseUp);
  var wrappedOnBlur = (0, _utils.useWrapEvent)(handleBlur, onBlur);
  var wrappedOnClick = (0, _utils.useWrapEvent)(handleClick, onClick);
  var wrappedOnFocus = (0, _utils.useWrapEvent)(handleFocus, onFocus);
  var wrappedOnMouseDown = (0, _utils.useWrapEvent)(handleMouseDown, onMouseDown);
  var wrappedOnKeyDown = (0, _utils.useWrapEvent)(handleKeyDown, onKeyDown);
  return {
    onBlur: wrappedOnBlur,
    onClick: wrappedOnClick,
    onFocus: wrappedOnFocus,
    onKeyDown: wrappedOnKeyDown,
    onMouseDown: wrappedOnMouseDown
  };
}
//# sourceMappingURL=useInputEvents.js.map