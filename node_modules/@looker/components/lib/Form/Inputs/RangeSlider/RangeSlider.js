"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RangeSlider = exports.InternalRangeSlider = void 0;

var _react = _interopRequireWildcard(require("react"));

var _designTokens = require("@looker/design-tokens");

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _sortBy = _interopRequireDefault(require("lodash/sortBy"));

var _indexOf = _interopRequireDefault(require("lodash/indexOf"));

var _startsWith = _interopRequireDefault(require("lodash/startsWith"));

var _partial = _interopRequireDefault(require("lodash/partial"));

var _map = _interopRequireDefault(require("lodash/map"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _utils = require("../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var sort = arr => arr.sort((a, b) => a - b);

var findClosestIndex = (value, newPoint) => {
  var {
    index: closestIndex
  } = (0, _sortBy.default)(value.map((p, i) => ({
    distance: Math.abs(p - newPoint),
    index: i
  })), 'distance')[0];
  return closestIndex;
};

var createNewValue = (value, newPoint, focusedIndex) => {
  var indexToReplace = focusedIndex === undefined ? findClosestIndex(value, newPoint) : focusedIndex;
  var newValue = Object.assign([], value, {
    [indexToReplace]: newPoint
  });
  return sort(newValue);
};

var roundToStep = (min, max, newPoint, step) => {
  var roundedPoint = Math.round((newPoint - min) / step) * step + min;
  return Math.max(Math.min(roundedPoint, max), min);
};

var calculatePointValue = (mouseX, containerRect, min, max, step) => {
  var mousePosition = mouseX - containerRect.left;
  var possibleValueRange = max - min;
  var newPoint = mousePosition / containerRect.width * possibleValueRange + min;
  return roundToStep(min, max, newPoint, step);
};

var boundValueProp = (min, max, value) => {
  return (0, _map.default)(value || [min, max], point => {
    var boundedPoint = Math.max(Math.min(point, max), min);

    if (boundedPoint !== point) {
      console.warn("<RangeSlider />: The value '".concat(point, "' falls outside the possible range (MIN: ").concat(min, ", MAX: ").concat(max, "). Please adjust min and max props accordingly."));
    }

    return boundedPoint;
  });
};

var InternalRangeSlider = (0, _react.forwardRef)((_ref, ref) => {
  var {
    className,
    id,
    min = 0,
    max = 10,
    step = 1,
    value: valueProp,
    defaultValue: defaultValueProp,
    onChange,
    disabled = false,
    readOnly: readOnlyProp = false,
    'aria-labelledby': ariaLabelledby
  } = _ref;
  var unintentionalReadOnly = (0, _utils.useReadOnlyWarn)('RangeSlider', valueProp, onChange);
  var readOnly = readOnlyProp || unintentionalReadOnly;
  var boundedValue = boundValueProp(min, max, valueProp || defaultValueProp);
  var [value, setValue] = (0, _react.useState)(sort(boundedValue));
  var [containerRef, setContainerRef] = (0, _react.useState)(null);
  var [focusedThumb, setFocusedThumb] = (0, _react.useState)();
  var containerRect = (0, _utils.useMeasuredElement)(containerRef);
  var {
    mousePos,
    isMouseDown
  } = (0, _utils.useMouseDragPosition)(containerRef);
  var prevMouseDown = (0, _utils.usePreviousValue)(isMouseDown);
  var minThumbRef = (0, _react.useRef)(null);
  var maxThumbRef = (0, _react.useRef)(null);
  var [minValue, maxValue] = value;
  var minPos = (minValue - min) / (max - min) * containerRect.width;
  var maxPos = (maxValue - min) / (max - min) * containerRect.width;
  var fillWidth = maxPos - minPos;
  var thumbRefs = [minThumbRef, maxThumbRef];

  var focusChangedPoint = (newValue, newPoint) => {
    var indexToFocus = (0, _indexOf.default)(newValue, newPoint);
    var refToFocus = thumbRefs[indexToFocus];
    requestAnimationFrame(() => {
      refToFocus.current && refToFocus.current.focus();
    });
  };

  var incrementPoint = point => {
    return Math.min(point + step, max);
  };

  var decrementPoint = point => {
    return Math.max(point - step, min);
  };

  var handleKeyboardNav = e => {
    if (!disabled && !readOnly) {
      if ((0, _startsWith.default)(e.key, 'Arrow') && focusedThumb !== undefined) {
        e.preventDefault();
        var unfocusedThumb = focusedThumb === 0 ? 1 : 0;
        var mutationFn = e.key === 'ArrowUp' || e.key === 'ArrowRight' ? incrementPoint : decrementPoint;
        var newPoint = mutationFn(value[focusedThumb]);
        var newValue = sort([newPoint, value[unfocusedThumb]]);
        focusChangedPoint(newValue, newPoint);
        setValue(newValue);
      }
    }
  };

  var focusMinThumb = () => {
    if (!disabled && !readOnly) {
      setFocusedThumb(0);
    }
  };

  var focusMaxThumb = () => {
    if (!disabled && !readOnly) {
      setFocusedThumb(1);
    }
  };

  var handleBlur = () => {
    setFocusedThumb(undefined);
  };

  var handleMouseEvent = maintainFocus => {
    if (!disabled && !readOnly) {
      var newPoint = calculatePointValue(mousePos.x, containerRect, min, max, step);
      var newValue = createNewValue(value, newPoint, maintainFocus ? focusedThumb : undefined);
      focusChangedPoint(newValue, newPoint);
      setValue(newValue);
    }
  };

  var handleMouseDown = (0, _partial.default)(handleMouseEvent, false);
  var handleMouseDrag = (0, _partial.default)(handleMouseEvent, true);
  (0, _react.useEffect)(() => {
    if (isMouseDown && prevMouseDown) {
      handleMouseDrag();
    }
  }, [mousePos, isMouseDown]);
  (0, _react.useEffect)(() => {
    var boundedValue = boundValueProp(min, max, valueProp);

    if (!(0, _isEqual.default)(value, boundedValue)) {
      setValue(sort(boundedValue));
    }
  }, [valueProp]);
  (0, _react.useEffect)(() => {
    if (!(0, _isEqual.default)(value, valueProp)) {
      onChange && onChange(value);
    }
  }, [value]);
  return _react.default.createElement("div", {
    "data-testid": "range-slider-wrapper",
    onMouseDown: handleMouseDown,
    className: className,
    id: id,
    ref: setContainerRef
  }, _react.default.createElement(SliderTrack, {
    ref: ref
  }, _react.default.createElement(SliderFill, {
    fillStart: minPos,
    fillWidth: fillWidth,
    disabled: disabled
  }), _react.default.createElement(ThumbLabel, {
    position: minPos,
    focus: focusedThumb === 0,
    disabled: disabled
  }, minValue), _react.default.createElement(ThumbLabel, {
    position: maxPos,
    focus: focusedThumb === 1,
    disabled: disabled
  }, maxValue), _react.default.createElement(Thumb, {
    position: minPos,
    tabIndex: disabled ? '-1' : '0',
    onFocus: focusMinThumb,
    onBlur: handleBlur,
    onKeyDown: handleKeyboardNav,
    ref: minThumbRef,
    disabled: disabled,
    "aria-label": "Minimum Value",
    role: "slider",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-disabled": disabled,
    "aria-valuenow": value[0],
    "aria-labelledby": ariaLabelledby
  }), _react.default.createElement(Thumb, {
    position: maxPos,
    tabIndex: disabled ? '-1' : '0',
    onFocus: focusMaxThumb,
    onBlur: handleBlur,
    onKeyDown: handleKeyboardNav,
    ref: maxThumbRef,
    disabled: disabled,
    "aria-label": "Maximum Value",
    role: "slider",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-disabled": disabled,
    "aria-valuenow": value[1],
    "aria-labelledby": ariaLabelledby
  })));
});
exports.InternalRangeSlider = InternalRangeSlider;
InternalRangeSlider.displayName = 'InternalRangeSlider';
var RangeSlider = (0, _styledComponents.default)(InternalRangeSlider).withConfig({
  displayName: "RangeSlider",
  componentId: "sc-1w8bpgp-0"
})(["", " ", " ", " padding:1.5rem 0 0.5rem;"], _designTokens.reset, _designTokens.space, _designTokens.typography);
exports.RangeSlider = RangeSlider;
RangeSlider.defaultProps = {
  fontSize: 'small',
  lineHeight: 'xsmall'
};

var SliderTrack = _styledComponents.default.div.withConfig({
  displayName: "RangeSlider__SliderTrack",
  componentId: "sc-1w8bpgp-1"
})(["background:", ";border-radius:2px;height:4px;position:relative;"], (_ref2) => {
  var {
    theme
  } = _ref2;
  return theme.colors.ui2;
});

var ThumbLabel = _styledComponents.default.div.withConfig({
  displayName: "RangeSlider__ThumbLabel",
  componentId: "sc-1w8bpgp-2"
})(["background:", ";border-radius:1rem;color:", ";padding:0 0.5rem;position:absolute;text-align:center;top:-24px;transform:translateX(calc(", " - 50%));user-select:none;z-index:", ";"], (_ref3) => {
  var {
    theme,
    focus
  } = _ref3;
  return focus ? theme.colors.keyAccent : "rgba(255, 255, 255, 0.8)";
}, (_ref4) => {
  var {
    theme: {
      colors
    },
    disabled
  } = _ref4;
  return disabled ? colors.neutral : colors.key;
}, (_ref5) => {
  var {
    position = 0
  } = _ref5;
  return "".concat(position, "px");
}, (_ref6) => {
  var {
    focus
  } = _ref6;
  return focus ? 1 : 0;
});

var Thumb = _styledComponents.default.div.withConfig({
  displayName: "RangeSlider__Thumb",
  componentId: "sc-1w8bpgp-3"
})(["background:", ";border:3px solid ", ";border-radius:100%;cursor:pointer;height:16px;margin-left:-8px;position:absolute;top:-6px;transform:translateX(", ");width:16px;&:focus{border-width:", ";outline:none;z-index:1;}"], (_ref7) => {
  var {
    theme
  } = _ref7;
  return theme.colors.field;
}, (_ref8) => {
  var {
    theme: {
      colors
    },
    disabled
  } = _ref8;
  return disabled ? colors.neutral : colors.key;
}, (_ref9) => {
  var {
    position = 0
  } = _ref9;
  return "".concat(position, "px");
}, (_ref10) => {
  var {
    disabled
  } = _ref10;
  return disabled ? '3px' : '5px';
});

var SliderFill = _styledComponents.default.div.withConfig({
  displayName: "RangeSlider__SliderFill",
  componentId: "sc-1w8bpgp-4"
})(["background:", ";height:100%;left:", "px;position:absolute;width:", "px;"], (_ref11) => {
  var {
    theme: {
      colors
    },
    disabled
  } = _ref11;
  return disabled ? colors.neutral : colors.key;
}, (_ref12) => {
  var {
    fillStart
  } = _ref12;
  return fillStart;
}, (_ref13) => {
  var {
    fillWidth
  } = _ref13;
  return fillWidth;
});
//# sourceMappingURL=RangeSlider.js.map