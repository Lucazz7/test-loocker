"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePopover = usePopover;
exports.Popover = Popover;

var _react = _interopRequireWildcard(require("react"));

var _Layout = require("../Layout");

var _Portal = require("../Portal");

var _Dialog = require("../Dialog");

var _OverlaySurface = require("../Overlay/OverlaySurface");

var _utils = require("../utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function isRenderProp(children) {
  return typeof children === 'function';
}

function useVerticalSpace(element, pin, placement, isOpen) {
  var [spaceTop, setSpaceTop] = (0, _react.useState)(0);
  var [spaceBottom, setSpaceBottom] = (0, _react.useState)(0);
  var placementIsBottom = placement && placement.includes('bottom');
  var placementIsTop = placement && placement.includes('top');
  (0, _react.useEffect)(() => {
    function getVerticalSpace() {
      if (element) {
        if (placementIsBottom || placementIsTop) {
          var {
            top,
            bottom
          } = element.getBoundingClientRect();

          if (!pin || placementIsTop) {
            setSpaceTop(top);
          } else if (pin) {
            setSpaceTop(0);
          }

          if (!pin || placementIsBottom) {
            setSpaceBottom(window.innerHeight - bottom);
          } else if (pin) {
            setSpaceBottom(0);
          }
        } else {
          setSpaceTop(window.innerHeight);
        }
      }
    }

    if (isOpen) {
      window.addEventListener('resize', getVerticalSpace);
      getVerticalSpace();
    }

    return () => {
      window.removeEventListener('resize', getVerticalSpace);
    };
  }, [element, pin, placementIsBottom, placementIsTop, isOpen]);
  var max = Math.max(spaceTop, spaceBottom);
  var windowHeight = typeof window !== "undefined" ? window.innerHeight : 50;
  return max > 50 ? max : windowHeight;
}

function useOpenWithoutElement(isOpen, element) {
  var [openWithoutElem, setOpenWithoutElem] = (0, _react.useState)(isOpen && element === null);
  (0, _react.useEffect)(() => {
    if (element && openWithoutElem) {
      setOpenWithoutElem(false);
    }
  }, [openWithoutElem, element]);
  return openWithoutElem;
}

function isNodeInOrAfter(nodeA, nodeB) {
  var relationship = nodeA.compareDocumentPosition(nodeB);
  return relationship === Node.DOCUMENT_POSITION_FOLLOWING || relationship === Node.DOCUMENT_POSITION_FOLLOWING + Node.DOCUMENT_POSITION_CONTAINED_BY;
}

function usePopoverToggle(_ref, portalElement, triggerElement) {
  var {
    isOpen: controlledIsOpen = false,
    setOpen: controlledSetOpen,
    canClose,
    groupedPopoversRef,
    triggerToggle
  } = _ref;
  var [uncontrolledIsOpen, uncontrolledSetOpen] = (0, _react.useState)(controlledIsOpen);
  var [mouseDownTarget, setMouseDownTarget] = (0, _react.useState)(null);
  var isControlled = (0, _utils.useControlWarn)({
    controllingProps: ['setOpen'],
    isControlledCheck: () => controlledSetOpen !== undefined,
    name: 'usePopover'
  });
  var isOpen = isControlled ? controlledIsOpen : uncontrolledIsOpen;
  var setOpen = isControlled && controlledSetOpen ? controlledSetOpen : uncontrolledSetOpen;
  (0, _react.useEffect)(() => {
    function checkCloseAndStopEvent(event) {
      if (canClose && !canClose()) return;

      if (portalElement && mouseDownTarget) {
        if (isNodeInOrAfter(portalElement, mouseDownTarget)) {
          return;
        }
      }

      if (portalElement && isNodeInOrAfter(portalElement, event.target)) {
        return;
      }

      var clickedOnToggle = triggerElement && triggerElement.contains(event.target);

      if (!triggerToggle && clickedOnToggle) {
        return;
      }

      setOpen(false);

      if (clickedOnToggle) {
        event.stopPropagation();
        return;
      }

      if (groupedPopoversRef && groupedPopoversRef.current && groupedPopoversRef.current.contains(event.target)) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();
    }

    function handleMouseDown(event) {
      setMouseDownTarget(event.target);
      checkCloseAndStopEvent(event);
    }

    function handleClickOutside(event) {
      checkCloseAndStopEvent(event);
      setMouseDownTarget(null);
    }

    function handleMouseUp() {
      setMouseDownTarget(null);
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleMouseDown, true);
      document.addEventListener('click', handleClickOutside, true);
    } else if (mouseDownTarget) {
      document.addEventListener('click', handleClickOutside, true);
      document.addEventListener('mouseup', handleMouseUp, true);
    }

    return () => {
      document.removeEventListener('mousedown', handleMouseDown, true);
      document.removeEventListener('click', handleClickOutside, true);
      document.removeEventListener('mouseup', handleMouseUp, true);
    };
  }, [canClose, groupedPopoversRef, isOpen, setOpen, triggerElement, portalElement, triggerToggle, mouseDownTarget]);
  return [isOpen, setOpen];
}

function usePopover(_ref2) {
  var {
    arrow = true,
    canClose,
    content,
    groupedPopoversRef,
    pin = false,
    isOpen: controlledIsOpen = false,
    onClose,
    placement: propsPlacement = 'bottom',
    setOpen: controlledSetOpen,
    triggerElement,
    triggerToggle = true,
    focusTrap = true
  } = _ref2;
  var {
    element: scrollElement,
    callbackRef: scrollRef,
    enable: enableScrollLock,
    isEnabled: scrollLockEnabled,
    disable: disableScrollLock
  } = (0, _utils.useScrollLock)(controlledIsOpen, true);
  var {
    callbackRef: focusRef,
    enable: enableFocusTrap,
    isEnabled: focusTrapEnabled,
    disable: disableFocusTrap,
    trapRef: focusTrapRef
  } = (0, _utils.useFocusTrap)(controlledIsOpen && focusTrap);
  var {
    focusTrapRef: parentFocusTrapRef
  } = (0, _react.useContext)(_Dialog.DialogContext);
  var [newTriggerElement, callbackRef] = (0, _utils.useCallbackRef)();
  var element = typeof triggerElement === 'undefined' ? newTriggerElement : triggerElement;
  var [isOpen, setOpen] = usePopoverToggle({
    canClose,
    groupedPopoversRef,
    isOpen: controlledIsOpen,
    setOpen: controlledSetOpen,
    triggerToggle
  }, scrollElement, element);
  var verticalSpace = useVerticalSpace(element, pin, propsPlacement, isOpen);
  var openWithoutElem = useOpenWithoutElement(isOpen, element);
  (0, _react.useEffect)(() => {
    if (isOpen) {
      if (focusTrap) {
        enableFocusTrap();
      } else {
        parentFocusTrapRef && parentFocusTrapRef.current && parentFocusTrapRef.current.pause();
      }
    } else if (!focusTrap) {
      parentFocusTrapRef && parentFocusTrapRef.current && parentFocusTrapRef.current.unpause();
    }
  }, [focusTrap, parentFocusTrapRef, isOpen, enableFocusTrap]);

  function handleOpen(event) {
    setOpen(true);
    enableScrollLock();
    event.stopPropagation();
    event.preventDefault();
  }

  function handleClose() {
    if (canClose && !canClose()) return;
    setOpen(false);
    onClose && onClose();
  }

  var usePopperProps = (0, _react.useMemo)(() => ({
    anchor: element,
    arrow,
    options: {
      modifiers: [{
        enabled: !pin,
        name: 'flip',
        options: {
          flipVariations: true,
          flipVariationsByContent: true
        }
      }, {
        enabled: true,
        name: 'eventListeners',
        options: {
          scroll: false
        }
      }],
      placement: propsPlacement
    }
  }), [arrow, element, pin, propsPlacement]);
  var {
    arrowProps,
    placement,
    popperInstanceRef,
    style,
    targetRef
  } = (0, _utils.usePopper)(usePopperProps);
  var ref = (0, _utils.useForkedRef)(targetRef, focusRef);
  var [containerElement, contentContainerRef] = (0, _utils.useCallbackRef)();

  var popover = !openWithoutElem && isOpen && _react.default.createElement(_Dialog.DialogContext.Provider, {
    value: {
      closeModal: handleClose,
      disableFocusTrap,
      disableScrollLock,
      enableFocusTrap,
      enableScrollLock,
      focusTrapEnabled,
      focusTrapRef,
      scrollLockEnabled
    }
  }, _react.default.createElement(_Portal.Portal, {
    ref: scrollRef
  }, _react.default.createElement(_OverlaySurface.OverlaySurface, {
    arrow: arrow,
    arrowProps: arrowProps,
    placement: placement,
    ref: ref,
    style: style,
    backgroundColor: "background",
    border: "1px solid",
    borderColor: "ui2",
    borderRadius: "medium",
    boxShadow: 3,
    color: "text1"
  }, _react.default.createElement(_Layout.Box, {
    maxHeight: "calc(".concat(verticalSpace - 10, "px - 1rem)"),
    overflowY: "auto",
    borderRadius: "inherit",
    ref: contentContainerRef
  }, content))));

  return {
    contentContainer: containerElement,
    isOpen,
    open: handleOpen,
    popover,
    popperInstanceRef,
    ref: callbackRef
  };
}

function Popover(_ref3) {
  var {
    children,
    hoverDisclosureRef
  } = _ref3,
      props = _objectWithoutProperties(_ref3, ["children", "hoverDisclosureRef"]);

  var popoverProps = usePopover(props);
  var target = children;
  var popoverPropsLabeled = {
    'aria-expanded': popoverProps.isOpen,
    'aria-haspopup': true,
    className: popoverProps.isOpen ? 'active' : '',
    onClick: popoverProps.open,
    ref: popoverProps.ref
  };

  if ((0, _react.isValidElement)(children)) {
    target = (0, _react.cloneElement)(children, _objectSpread(_objectSpread({}, popoverPropsLabeled), {}, {
      className: popoverProps.isOpen ? "".concat(children.props.className, " active") : children.props.className
    }));
  } else if (isRenderProp(children)) {
    target = children(popoverPropsLabeled);
  } else {
    console.warn("Element \"".concat(typeof target, "\" can't be used as target for Popover"));
  }

  var [isHovered] = (0, _utils.useHovered)(hoverDisclosureRef);
  var triggerShown = isHovered || popoverProps.isOpen;
  return _react.default.createElement(_react.default.Fragment, null, popoverProps.popover, triggerShown && target);
}
//# sourceMappingURL=Popover.js.map